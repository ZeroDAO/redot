// Copyright 2023 ZeroDAO
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///! Frost DKG and signing implementation
///
/// This is a specific implementation of threshold signature, which can be verified in a `no-std` environment,
/// thus enabling on-chain verification in Substrate. Currently, it does not support generation and signing
/// in `no-std`. FROST is used as the underlying cryptographic library. FROST is a threshold signature scheme. It allows splitting a Schnorr signing key
/// into n shares for a threshold t, such that t (or more) participants can together generate a signature
/// that can be validated by the corresponding verifying key. An important aspect is that the resulting
/// signature is indistinguishable from a non-threshold signature from the viewpoint of signature
/// verifiers. You can learn more at [https://frost.zfnd.org/frost.html](https://frost.zfnd.org/frost.html).
use crate::DkgVerifyingKey;
use anyhow::{anyhow, Context, Ok, Result};
use codec::{Decode, Encode, EncodeLike, MaxEncodedLen};
use frost::keys::dkg::round1::{Package as Round1Package, SecretPackage as Round1Secret};
use frost::keys::dkg::round2::{Package as Round2Package, SecretPackage as Round2Secret};
use frost::round1::{SigningCommitments, SigningNonces};
use frost::round2::SignatureShare;
use frost_ed25519::{self as frost, Identifier};
use scale_info::{build::Fields, Path, Type, TypeInfo};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

/// Wrapper for DkgVerifyingKey, facilitating usage in different encoding contexts
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct WrapVerifyingKey(pub DkgVerifyingKey);

impl MaxEncodedLen for WrapVerifyingKey {
	fn max_encoded_len() -> usize {
		32
	}
}

impl TypeInfo for WrapVerifyingKey {
	type Identity = Self;

	fn type_info() -> Type {
		Type::builder()
			.path(Path::new("DkgVerifyingKey", module_path!()))
			.composite(Fields::unit())
	}
}

impl Encode for WrapVerifyingKey {
	fn encode_to<T: codec::Output + ?Sized>(&self, dest: &mut T) {
		let serialized = self.0.serialize();
		dest.write(&serialized);
	}
}

impl Decode for WrapVerifyingKey {
	fn decode<I: codec::Input>(input: &mut I) -> Result<Self, codec::Error> {
		let bytes: Vec<u8> = Vec::decode(input)?;
		let fixed_bytes: [u8; 32] = bytes
			.try_into()
			.map_err(|_| codec::Error::from("Length mismatch when decoding VerifyingKey"))?;

		DkgVerifyingKey::deserialize(fixed_bytes)
			.map(WrapVerifyingKey) // Wrap the VerifyingKey in DkgVerifyingKey
			.map_err(|_| codec::Error::from("Error decoding DkgVerifyingKey"))
	}
}

impl EncodeLike for WrapVerifyingKey {}

/// Two-round messages for key generation negotiation
#[derive(Serialize, Deserialize, Clone)]
pub enum DkgMessage {
	DkgPart1(DkgPart1Message),
	DkgPart2(DkgPart2Message),
}

/// Two-round messages for signature negotiation
#[derive(Serialize, Deserialize, Clone)]
pub enum SignMessage {
	SignPart1(SignPart1Message),
	SignPart2(SignPart2Message),
}

/// First-round message for key generation negotiation
#[derive(Serialize, Deserialize, Clone)]
pub struct DkgPart1Message {
	/// Identity identifier generated by the sender
	pub id: Identifier,
	/// Generated Package
	pub part1: Round1Package,
}

/// Second-round message for key generation negotiation
#[derive(Serialize, Deserialize, Clone)]
pub struct DkgPart2Message {
	/// Identity identifier generated by the sender
	pub id: Identifier,
	/// Generated Package, containing the packages generated by the creator for all participants except themselves
	pub part2: BTreeMap<Identifier, Round2Package>,
}

/// First-round message for signature negotiation
#[derive(Serialize, Deserialize, Clone)]
pub struct SignPart1Message {
	/// Identity identifier generated by the sender
	pub id: Identifier,
	/// Generated Commitment
	pub part1: SigningCommitments,
}

/// Second-round message for signature negotiation
#[derive(Serialize, Deserialize, Clone)]
pub struct SignPart2Message {
	/// Identity identifier generated by the sender
	pub id: Identifier,
	/// Generated SignatureShare
	pub part2: SignatureShare,
}

pub struct DkgKeypair {
	pub key: frost::keys::KeyPackage,
	pub public: frost::keys::PublicKeyPackage,
}

/// Represents the state and functionality of a participant in the Frost Distributed Key Generation (DKG) protocol.
///
/// The `FrostDkg` struct encapsulates all necessary data and methods for a participant to engage in both the DKG process
/// for generating a shared public key and the threshold signing process. It handles two-phase commit-reveal schemes for
/// both key generation and signing, ensuring that the processes are carried out correctly and securely.
pub struct FrostDkg {
	// The current DKG keypair, if already generated
	dkg_keypair: Option<DkgKeypair>,
	// Stores round 2 packages from other participants in the DKG process
	round2_packages: BTreeMap<Identifier, Round2Package>,
	// TODO: Add coordinator support
	#[allow(dead_code)]
	is_coordinator: bool,
	// Stores the round 1 secret, to be used in the next round
	round1_secret: Option<Round1Secret>,
	// Stores the round 1 package, to be used in the next round
	round1_package: Option<Round1Package>,
	// Stores round 1 packages from other participants
	round1_packages: BTreeMap<Identifier, Round1Package>,
	// Stores the round 2 secret, necessary to generate the final result
	round2_secret: Option<Round2Secret>,
	// Threshold value 't' for the DKG and signing process
	t: u16,
	// Number of participants 'n' in the DKG and signing process
	n: u16,
	// Stores commitments for the signing negotiation
	signing_commitments: BTreeMap<Identifier, SigningCommitments>,
	// Stores nonces for the first round of the signing process
	sign_round1_nonce: Option<SigningNonces>,
	// Stores the package for the signing negotiation
	signing_package: Option<frost::SigningPackage>,
	// Stores signature shares for the second round of the signing process
	sign_round2_signature_shares: BTreeMap<Identifier, SignatureShare>,
	// Stores the message to be signed
	sign_message: Vec<u8>,
	// The identifier of the participant
	id: Identifier,
}

impl FrostDkg {
	/// Initializes a new `FrostDkg` instance with a given identifier.
	///
	/// The identifier uniquely represents a participant in the DKG and signing processes.
	///
	/// # Arguments
	///
	/// * `id` - The unique identifier for this participant.
	pub fn new(id: Identifier) -> Self {
		Self {
			dkg_keypair: None,
			round2_packages: BTreeMap::new(),
			is_coordinator: false,
			round1_secret: None,
			round1_package: None,
			round1_packages: BTreeMap::new(),
			round2_secret: None,
			t: 0,
			n: 0,
			signing_commitments: BTreeMap::new(),
			sign_round1_nonce: None,
			signing_package: None,
			sign_round2_signature_shares: BTreeMap::new(),
			sign_message: vec![],
			id,
		}
	}

	/// Sets the 'n' (number of participants) and 't' (threshold) values for the DKG instance.
	///
	/// This should be agreed upon by all participants before starting the DKG process.
	///
	/// # Arguments
	///
	/// * `n` - The total number of participants in the DKG process.
	/// * `t` - The threshold number of participants required to generate a valid signature.
	///
	/// # Returns
	///
	/// Returns `Ok(())` if successfully set, or an error if `n` is less than `t`.
	pub fn set_nt(&mut self, n: u16, t: u16) -> Result<()> {
		if n < t {
			return Err(anyhow!("n must be greater than t"));
		}
		self.n = n;
		self.t = t;
		Ok(())
	}

	/// Prepares for signing by generating the first round of signing commitments.
	///
	/// This process should be triggered by some signal to ensure all participants start the process,
	/// often based on some on-chain data in a blockchain context.
	///
	/// # Arguments
	///
	/// * `msg` - The message that needs to be signed.
	///
	/// # Returns
	///
	/// Returns the first-round message of the signing negotiation, which should be sent only to the coordinator.
	pub fn start_sign(&mut self, msg: &[u8]) -> Result<SignMessage> {
		if let Some(dkg_keypair) = &self.dkg_keypair {
			self.sign_message = msg.to_vec();
			let (nonce, commitment) =
				frost::round1::commit(&dkg_keypair.key.signing_share(), &mut rand::rngs::OsRng);

			self.sign_round1_nonce = Some(nonce);

			self.signing_commitments.insert(self.id, commitment.clone());

			let message =
				SignMessage::SignPart1(SignPart1Message { id: self.id, part1: commitment });
			Ok(message)
		} else {
			Err(anyhow!("DKG keypair not initialized"))
		}
	}

	/// Used by the coordinator to collect first-round messages from other participants, generate the second round
	/// of signing messages, and broadcast them to other participants.
	///
	/// This implementation assumes that the previous round's messages are sent to all participants, allowing
	/// all of them to independently complete the signing process. In practice, this function should be split into
	/// two steps for efficiency.
	///
	/// # Return
	///
	/// Returns the second-round message of the signing negotiation, which needs to be broadcast to all other participants.
	pub fn sign_part1(
		&mut self,
		sign_part1_message: SignPart1Message,
	) -> Result<Option<SignMessage>> {
		self.signing_commitments.insert(sign_part1_message.id, sign_part1_message.part1);

		if self.signing_commitments.len() == self.n as usize {
			if let Some(nonce) = self.sign_round1_nonce.clone() {
				let signing_package = frost::SigningPackage::new(
					self.signing_commitments.clone(),
					self.sign_message.as_slice(),
				);

				self.signing_package = Some(signing_package.clone());

				if let Some(dkg_keypair) = &self.dkg_keypair {
					let share = frost::round2::sign(&signing_package, &nonce, &dkg_keypair.key)
						.context("Failed to sign in SignPart1")?;

					self.sign_round2_signature_shares.insert(self.id, share);

					return Ok(Some(SignMessage::SignPart2(SignPart2Message {
						id: self.id,
						part2: share,
					})));
				} else {
					return Err(anyhow!("DKG keypair not initialized"));
				}
			} else {
				return Err(anyhow!("No nonce available for signing"));
			}
		}
		Ok(None)
	}

	/// Called after collecting second-round messages from other participants to generate the final aggregated signature.
	///
	/// Note: If a participant behaves improperly by generating an incorrect signature, the aggregation will fail.
	/// In a blockchain environment, the identity of the misbehaving participant can be identified, and appropriate
	/// penalties should be applied, along with their removal from the participant list.
	pub fn sign_part2(
		&mut self,
		sign_part2_message: SignPart2Message,
	) -> Result<Option<frost::Signature>> {
		self.sign_round2_signature_shares
			.insert(sign_part2_message.id, sign_part2_message.part2);

		if self.sign_round2_signature_shares.len() == self.n as usize {
			if let (Some(signing_package), Some(dkg_keypair)) =
				(&self.signing_package, &self.dkg_keypair)
			{
				let sign = frost::aggregate(
					&signing_package,
					&self.sign_round2_signature_shares,
					&dkg_keypair.public,
				)?;
				return Ok(Some(sign));
			} else {
				return Err(anyhow!("Signing package or DKG keypair not initialized"));
			}
		}
		Ok(None)
	}

	/// Starts the key generation negotiation by generating the first round of DKG messages, which should be broadcast
	/// to all other participants.
	///
	/// # Note
	///
	/// Care should be taken to ensure the security of the random numbers used.
	pub fn start_dkg(&mut self) -> Result<DkgMessage> {
		let (round1_secret, round1_package) =
			frost::keys::dkg::part1(self.id, self.n, self.t, &mut rand::rngs::OsRng)
				.context("Failed to generate DKG Part1 data")?;

		self.round1_secret = Some(round1_secret);
		self.round1_package = Some(round1_package.clone());

		Ok(DkgMessage::DkgPart1(DkgPart1Message { id: self.id, part1: round1_package }))
	}

	/// Processes the second round of key generation after receiving DKG Part2 messages from other participants.
	/// Generates a DKG VerifyingKey and returns it.
	pub fn dkg_part2(
		&mut self,
		dkg_part2_message: DkgPart2Message,
	) -> Result<Option<DkgVerifyingKey>> {
		if let Some(round2_secret) = &self.round2_secret {
			let my_package = dkg_part2_message.part2.get(&self.id);

			if let Some(my_package) = my_package {
				self.round2_packages.insert(dkg_part2_message.id, my_package.clone());
			} else {
				return Err(anyhow!("Missing own package in DKG Part2 processing"));
			}

			if self.round2_packages.len() + 1 == self.n as usize {
				let (key_package, public_key_package) = frost::keys::dkg::part3(
					round2_secret,
					&self.round1_packages,
					&self.round2_packages,
				)?;

				self.dkg_keypair =
					Some(DkgKeypair { key: key_package, public: public_key_package.clone() });

				return Ok(Some(public_key_package.verifying_key().clone()));
			}

			Ok(None)
		} else {
			Err(anyhow!("Missing secrets for DKG Part2 processing"))
		}
	}

	/// Processes the first round of key generation after receiving messages generated in `start_dkg()`.
	/// Generates a DKG Part2 message and broadcasts it to participants.
	pub fn dkg_part1(&mut self, dkg_part1_message: DkgPart1Message) -> Result<Option<DkgMessage>> {
		if dkg_part1_message.id == self.id {
			return Ok(None);
		}

		self.round1_packages.insert(dkg_part1_message.id, dkg_part1_message.part1);

		if self.round1_packages.len() + 1 == self.n as usize {
			if let Some(round1_secret) = &self.round1_secret {
				let (secret, packages) =
					frost::keys::dkg::part2(round1_secret.clone(), &self.round1_packages)
						.context("Error in DKG Part2 processing")?;

				self.round1_secret = None;

				self.round2_secret = Some(secret);

				let message =
					DkgMessage::DkgPart2(DkgPart2Message { id: self.id, part2: packages.clone() });

				return Ok(Some(message));
			} else {
				return Err(anyhow!("No Round1 secret available for DKG Part1 processing"));
			}
		}
		Ok(None)
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use ed25519_consensus::{Signature, VerificationKey};
	use std::collections::HashMap;

	// Helper function to create a FrostDkg instance
	// This function simplifies the creation of a FrostDkg instance for a given participant.
	// It sets the required values like the threshold (t), the number of participants (n), and the identifier (id).
	fn create_frost_dkg(id: Identifier, t: u16, n: u16) -> FrostDkg {
		FrostDkg {
			dkg_keypair: None,
			round2_packages: BTreeMap::new(),
			is_coordinator: false,
			round1_secret: None,
			round1_package: None,
			round1_packages: BTreeMap::new(),
			round2_secret: None,
			t,
			n,
			signing_commitments: BTreeMap::new(),
			sign_round1_nonce: None,
			signing_package: None,
			sign_round2_signature_shares: BTreeMap::new(),
			sign_message: vec![],
			id,
		}
	}

	#[test]
	fn full_dkg_and_signing_process() -> Result<()> {
		// Constants for threshold and total number of participants
		const T: u16 = 2;
		const N: u16 = 3;

		// Generate unique identifiers for each participant
		let ids = generate_identifiers(N);

		// Initialize FrostDkg instances for each participant
		// This simulates each participant in the DKG and signing process.
		let mut participants: HashMap<Identifier, FrostDkg> =
			ids.iter().map(|&id| (id, create_frost_dkg(id, T, N))).collect();

		// Step 1: Run DKG Part 1
		// Each participant generates their first round DKG message and stores it.
		let mut dkg_part1_messages = Vec::new();
		for id in ids.iter() {
			let dkg_message = participants.get_mut(id).unwrap().start_dkg()?;
			dkg_part1_messages.push((id, dkg_message));
		}

		// Process DKG Part 1 messages and prepare Part 2 messages
		let mut dkg_part2_messages = Vec::new();
		for (id, dkg_message) in &dkg_part1_messages {
			if let DkgMessage::DkgPart1(msg) = dkg_message {
				for &other_id in ids.iter() {
					if **id != other_id {
						if let Some(dkg_part2_message) =
							participants.get_mut(&other_id).unwrap().dkg_part1(msg.clone()).unwrap()
						{
							dkg_part2_messages.push((other_id, dkg_part2_message))
						}
					}
				}
			}
		}

		// Check that round2_secret is Some for all participants
		for id in ids.iter() {
			let participant = participants.get_mut(id).unwrap();
			assert!(participant.round2_secret.is_some());
		}

		// Send round2_package to other users
		for (id, dkg_part2_message) in &dkg_part2_messages {
			if let DkgMessage::DkgPart2(msg) = dkg_part2_message {
				for &other_id in ids.iter() {
					if *id != other_id {
						participants.get_mut(&other_id).unwrap().dkg_part2(msg.clone()).unwrap();
					}
				}
			}
		}

		// Check that dkg_keypair is Some for all participants
		for id in ids.iter() {
			let participant = participants.get_mut(id).unwrap();
			assert!(participant.dkg_keypair.is_some());
		}

		// Step 2: Start signing process
		// Each participant prepares to sign a common message.
		let sign_message = b"Test message".to_vec();
		let mut messages_to_send = Vec::new();
		for participant in participants.values_mut() {
			let sign_msg = participant.start_sign(sign_message.as_slice()).unwrap();

			if let SignMessage::SignPart1(msg) = sign_msg {
				messages_to_send.push((participant.id, msg));
			}
		}

		// Send and process sign_part1 messages
		let mut to_send = Vec::new();
		for (id, msg) in messages_to_send {
			for other_id in ids.iter() {
				if id != *other_id {
					if let Some(msg) =
						participants.get_mut(&other_id).unwrap().sign_part1(msg.clone())?
					{
						if let SignMessage::SignPart2(m) = msg {
							to_send.push((other_id, m));
						}
					}
				}
			}
		}

		// Check that sign_round1_nonce is Some
		let mut sing_vec = Vec::new();
		for (id, msg) in to_send {
			for other_id in ids.iter() {
				if id != other_id {
					if let Some(sign) =
						participants.get_mut(&other_id).unwrap().sign_part2(msg.clone())?
					{
						sing_vec.push(sign);
					}
				}
			}
		}

		// Assert that the length of sing_vec is equal to the number of participants
		assert!(sing_vec.len() == ids.len());

		// Retrieve the public key package from one of the participants
		let public_key_package =
			participants.get(&ids[0]).unwrap().dkg_keypair.as_ref().unwrap().public.clone();

		// Serialize the verifying key for use in signature verification
		let vk_bytes = public_key_package.verifying_key().serialize();

		// Verify the signatures
		// In practice, this step is not necessary because Frost already performs this verification.
		for sign in sing_vec {
			let res = public_key_package.verifying_key().verify(sign_message.as_slice(), &sign);
			assert!(res.is_ok());

			let sign_bytes = sign.serialize();
			let sign = Signature::try_from(sign_bytes).unwrap();

			let vk = VerificationKey::try_from(vk_bytes).unwrap();

			// Verify the signature
			vk.verify(&sign, sign_message.as_slice()).unwrap();
		}

		Ok(())
	}

	// Helper function to generate identifiers
	// This function generates a unique Identifier for each participant, based on a simple numeric sequence.
	fn generate_identifiers(n: u16) -> Vec<Identifier> {
		(0..n).map(|id| Identifier::derive(&id.to_le_bytes()).unwrap()).collect()
	}
}
